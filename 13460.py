# 13460 : Bead escape
"""
생각보다 어려웠던 문제. 2시간 투자함..
제한시간 있었으면 못풀었을듯.

[제약조건]
1. 두 구슬은 상하좌우로 움직인다 + 이동 동작은 더이상 구슬이 움직이지 못할때까지!
2. 두 구슬은 동시에 움직인다.
3. 두 구슬은 같은 칸에 존재할 수 없다.
4. 파란 구슬은 구멍에 빠지면 안된다.


[제약조건 분석]
 <1번>
 => DFS 또는 BFS 맹목적 탐색 이용 가능.
 
 선택 기준은 다음과 같다.
 "정답 기준은 최대인가 최소인가"
 => 최소이다.
 "한 노드쪽으로 깊게 들어가야하는가"
 => 한 기울기 동작마다 자식의 자식노드 즉 제한적으로 깊게 들어간다.
 => 최소 횟수는 다시 말해, 현재 빨간 구슬 위치를 기준으로 하므로, 자신의 자식 노드들을 각각 벽을 만날때까지 깊게 들어가는것.
 
 그러므로 bfs선택.
 
 <2번,3번>
 => 그래프 탐색 시, 움직임을 멈추는 경우는 다음과 같다.
 ==> 벽을 만났거나, 구멍에 들어갔을 경우.
 => 구멍에 들어간 경우, 정답 처리를 하면 됨.
 => 벽을 만났을때는, 그 경우에서 다음 자식 노드 탐색이 이루어져야 함.
 => 즉, 빨간구슬과 파란구슬이 같은 벽을 동시에 만나, 같은 위치가 됬을 경우 처리가 필요함.
 => 예제2번과 같은 상황, 왼쪽 기울기 했을 경우, 빨간 구슬이 앞에 있다는 사실을 통해
 => '거리가 더 많이 움직인 쪽을 한칸 뒤로 옮겨주면 됨.
 
 <4번>
 => "파란 구슬이 구멍에 빠진 즉시 정답 처리하면 안됨."
 => 파란 구슬이 구멍에 빠지면 실패일 뿐이지, 다른 경로로 빨간 구슬이 통과할 수 있음.
 => 즉, 파란 구슬이 구멍에 빠진 루트는 무시하면 됨.
 
 [알고리즘 해결 과정]
 1. bfs이므로, 큐를 사용.
 2. 빨간 및 파란 구슬의 경로 체크를 위한 방문 배열 visited 필요.
 ==> 방문 배열 이중 리스트 vs 단일 리스트
 ==> 탐색 과정에서, 다양한 좌표가 생성 가능.
 ==> 예제1) R/B(x,y) : R(3,1)-B(1,1)(2,1)(3,1) ...
 ==> 조합처럼, 여러 좌표가 루트 그 자체가 되기에, visited[][]==방문여부로 하게 되면, 경로가 꼬임.
 ==> v=[(R좌표,B좌표)]처럼 구현하여, not in v ? 여부를 통해 방문 여부 판단을 진행해야 함.
 3. 한 방향 탐색 시, 빨간 구슬 및 파란 구슬을 동시에 진행해야 함.
 ==> dx,dy 방향 리스트를 통해 for문을 이용.
 ==> for문의 내용에 빨간 구슬 및 파란 구슬 탐색이 함께 적혀있으면 됨.
 4. 파란 구슬 구멍에 빠진 경우 무시.
 ==> break가 아닌 continue!
 5. 정답 카운팅은 어떻게?
 ==> bfs횟수가 아님.
 ==> '기울기가 끝났을 경우에 카운팅이 이루어져야 됨.'
 ==> 즉, "그래프의 깊이를 카운팅 하는것."
 ==> q에 좌표 원소를 삽입할때, cnt를 원소로 같이 추가하면 해결.
 
 [알고리즘]
 1. bfs 탐색 시작.
 2. q에 (R좌표,B좌표,cnt) 세팅. (초기: (R,B,0)))
 3. while 반복문 시작.
 4-1. 빨간 구슬 구멍에 도착한 경우 정답 처리.
 4-2. 이동 횟수 10 초과 경우, 정답 처리.
 5. 4방향 탐색 시작. (for i in range(4))
 5-1. 현재 방향 기준, 벽 또는 구멍을 접할때까지 빨간 구슬 이동 탐색
 5-2. 현재 방향 기준, // 파란 구슬 이동 탐색
 5-3. 파란 구슬 좌표가 구멍이라면, 다음 방향 탐색으로 ㄱㄱ(현재 방향은 파란 구슬이 구멍에 빠지는 루트이므로)
 5-4. 현재 방향 기울기가 종료됬을시, 방문 안했으면, 이 좌표 기준 다음 루트 찾기 위해 방문 처리.
"""

import sys
from collections import deque
input=sys.stdin.readline

def bfs():
    # R좌표,B좌표,cnt 원소.
    q=deque([(r[0],r[1],b[0],b[1],0)])
    
    while q:
        rx,ry,bx,by,cnt=q.popleft()
        visited.add((rx,ry,bx,by))
        
        # R좌표가 구멍에 도착한 경우.
        if graph[rx][ry]=='O':
            print(cnt)
            return
        # 이동수가 10번 초과인 경우.
        if cnt>10:
            print(-1)
            return
        
        # 4방향 탐색 시작.
        for i in range(4):
            # R좌표 이동 탐색.
            nrx,nry=rx,ry
            while True:
                nrx+=dx[i]; nry+=dy[i]
                if graph[nrx][nry]=='#':
                    nrx-=dx[i]; nry-=dy[i]
                    break
                if graph[nrx][nry]=='O':
                    break
            
            # B좌표 이동 탐색.
            nbx,nby=bx,by
            while True:
                nbx+=dx[i]; nby+=dy[i]
                if graph[nbx][nby]=='#':
                    nbx-=dx[i]; nby-=dy[i]
                    break
                if graph[nbx][nby]=='O':
                    break
            
            # B좌표가 구멍에 들어간 경우 무시해야 함.
            # R좌표의 여부가 핵심이기에 B좌표가 구멍에 들어가지 않는 경우 탐색으로 스킵.
            if graph[nbx][nby]=='O':
                continue
            
            # R좌표==B좌표
            if nrx==nbx and nry==nby:
                # 현재 방향 기준으로 누가 더 멀리 움직였는가
                # 덜 움직인 쪽이 앞에 있는것.
                if abs(nrx-rx)+abs(nry-ry) > abs(nbx-bx)+abs(nby-by):
                    nrx-=dx[i]; nry-=dy[i]
                else:
                    nbx-=dx[i]; nby-=dy[i]
            
            # 방문하지 않은 곳이면, 방문처리 및 큐 추가.
            if (nrx,nry,nbx,nby) not in visited:
                q.append((nrx,nry,nbx,nby,cnt+1))
                visited.add((nrx,nry,nbx,nby))
    
    # 10회 초과는 아니지만, 구멍 내로 못들어간 경우.
    print(-1)
    

n,m=map(int,input().split())
graph=[]
visited=set() # 방문처리 배열
r,b=(),()
dx=[-1,1,0,0]
dy=[0,0,-1,1]

for i in range(n):
    l=[*input()]
    for j in range(m):
        if l[j]=='R':
            r=(i,j)
        elif l[j]=='B':
            b=(i,j)
    graph.append(l)

bfs()